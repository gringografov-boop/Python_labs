# Лабораторная работа 3
Алгоритмы и структуры данных

## Как запустить

```bash
python main.py          # основная программа
python tests/test_algorithms.py  # тесты
python benchmark.py     # бенчмарк
```

---

## src/algorithms.py

### Факториал и Фибоначчи

**factorial(n)** — вычисляет n! простым циклом. O(n), быстро.

**factorial_recursive(n)** — то же самое, но через рекурсию. O(n) по времени, но O(n) по памяти (стек). Медленнее обычного.

**fibo(n)** — вычисляет n-е число Фибоначчи в цикле. O(n), работает быстро даже для больших n.

**fibo_recursive(n)** — Фибоначчи через рекурсию. O(2^n) — очень медленно. Использовать только для маленьких n (до 30-35).

### Сортировки

**bubble_sort** — пузырьком. O(n²), медленно, но простая. Учебная.

**quick_sort** — быстрая сортировка. O(n log n) в среднем, очень быстро на практике.

**counting_sort** — сортирует через подсчёт. O(n + k), где k — диапазон чисел. Работает для целых чисел.

**radix_sort** — сортирует по разрядам (единицы, десятки и т.д.). O(d·(n+k)), где d — количество разрядов. Хороша для больших чисел.

**bucket_sort** — раскидывает элементы по корзинам и сортирует каждую. O(n + k) в среднем. Хороша для float в диапазоне [0, 1).

**heap_sort** — через кучу. O(n log n) всегда, очень надёжна.

### Стек (Stack)

LIFO структура — добавляешь сверху, берёшь сверху.

- `push(x)` — добавить
- `pop()` — убрать и вернуть верхний
- `peek()` — посмотреть верхний
- `min()` — минимум в стеке за O(1) (отслеживается параллельно)

Используется: отмена (Ctrl+Z), проверка скобок, DFS.

### Очередь (Queue)

FIFO структура — добавляешь в конец, берёшь с начала.

- `enqueue(x)` — добавить в конец
- `dequeue()` — убрать и вернуть первый
- `front()` — посмотреть первый

Используется: обработка задач по очереди, BFS, принтеры.

### Генераторы массивов

**rand_int_array(n, lo, hi, seed)** — случайные целые числа.

**nearly_sorted(n, swaps, seed)** — почти отсортированный массив (для тестирования на реальных данных).

**many_duplicates(n, k, seed)** — много дубликатов (тест на данных с повторениями).

**reverse_sorted(n)** — просто массив в обратном порядке.

**rand_float_array(n, seed)** — случайные float для bucket_sort.

### Бенчмарк

**timeit(func, arr)** — измеряет время работы функции.

**benchmark(arrays, algos)** — сравнивает несколько сортировок на разных типах массивов.

---

## Примеры

```python
from src.algorithms import *

# Факториал
print(factorial(5))  # 120

# Сортировка
arr = [5, 2, 8, 1]
print(quick_sort(arr))  # [1, 2, 5, 8]

# Стек
s = Stack()
s.push(10)
s.push(5)
print(s.min())  # 5

# Очередь
q = Queue()
q.enqueue(1)
q.enqueue(2)
print(q.dequeue())  # 1
```

---

## Особенности

- counting_sort работает со всеми целыми (со сдвигом по минимуму)
- radix_sort для всех
- bucket_sort автоматически нормализует float
- fibo_recursive медленная, не использовать для n > 35
